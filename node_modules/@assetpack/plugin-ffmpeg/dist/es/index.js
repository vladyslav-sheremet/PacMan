import { merge, checkExt, path, SavableAssetCache } from '@assetpack/core';
import fluentFfmpeg from 'fluent-ffmpeg';
import fs from 'fs-extra';

async function convert(output, tree, extname, processor, name) {
    return new Promise((resolve, reject) => {
        let hasOutput = false;
        const command = fluentFfmpeg();
        const paths = [];
        // add each format to the command as an output
        output.formats.forEach((format) => {
            const outPath = processor.inputToOutput(tree.path, format);
            fs.ensureDirSync(path.dirname(outPath));
            processor.addToTree({
                tree,
                outputOptions: {
                    outputPathOverride: outPath,
                },
                transformId: 'ffmpeg',
            });
            if (output.recompress || format !== extname) {
                command.output(outPath);
                hasOutput = true;
            }
            else {
                fs.copySync(tree.path, outPath);
            }
            paths.push(processor.trimOutputPath(outPath));
        });
        if (SavableAssetCache.has(tree.path)) {
            const cache = SavableAssetCache.get(tree.path);
            cache.transformData.files[0].paths.push(...paths);
            SavableAssetCache.set(tree.path, cache);
        }
        else {
            SavableAssetCache.set(tree.path, {
                tree,
                transformData: {
                    type: name,
                    files: [{
                            name: processor.trimOutputPath(processor.inputToOutput(tree.path)),
                            paths,
                        }],
                }
            });
        }
        if (!hasOutput) {
            resolve();
            return;
        }
        // add the input file
        command.input(tree.path);
        // add each option to the command
        Object.keys(output.options).forEach((key) => {
            const value = output.options[key];
            if (!command[key])
                throw new Error(`[ffmpeg] Unknown option: ${key}`);
            command[key](value);
        });
        // run the command
        command
            .on('error', reject)
            .on('end', resolve)
            .run();
    });
}
function ffmpeg(options) {
    const defaultOptions = merge(true, {
        inputs: [],
        outputs: [],
    }, options);
    return {
        folder: false,
        name: 'ffmpeg',
        test(tree, _p, optionOverrides) {
            const opts = merge(true, defaultOptions, optionOverrides);
            if (!opts.inputs.length) {
                throw new Error('[ffmpeg] No inputs defined');
            }
            return checkExt(tree.path, ...opts.inputs);
        },
        async transform(tree, processor, optionOverrides) {
            // merge options with defaults
            const opts = merge(true, defaultOptions, optionOverrides);
            const extname = path.extname(tree.path);
            const promises = [];
            opts.outputs.forEach((output) => {
                promises.push(convert(output, tree, extname, processor, this.name));
            });
            await Promise.all(promises);
        }
    };
}

function audio(options) {
    // default settings for converting mp3, ogg, wav to mp3, ogg
    let defaultOptions = {
        inputs: ['.mp3', '.ogg', '.wav'],
        outputs: [
            {
                formats: ['.mp3'],
                recompress: false,
                options: {
                    audioBitrate: 96,
                    audioChannels: 1,
                    audioFrequency: 48000,
                }
            },
            {
                formats: ['.ogg'],
                recompress: false,
                options: {
                    audioBitrate: 32,
                    audioChannels: 1,
                    audioFrequency: 22050,
                }
            },
        ]
    };
    defaultOptions = merge(true, defaultOptions, options);
    const audio = ffmpeg(defaultOptions);
    audio.name = 'audio';
    return audio;
}

export { audio, ffmpeg };
//# sourceMappingURL=index.js.map
