'use strict';

var core = require('@assetpack/core');
var fs = require('fs-extra');

function baseManifest(func, options) {
    const defaultOptions = {
        ...options,
        parsers: [options.defaultParser, ...options?.parsers || []],
    };
    let dirty = true;
    return {
        folder: false,
        test(tree) {
            if (!tree.state)
                return false;
            if (tree.state === 'added' || tree.state === 'deleted') {
                dirty = true;
            }
            // so we now only care if anything was added or removed, we don't care if it was modified!
            return false;
        },
        async delete() {
            dirty = true;
        },
        finish(tree, processor) {
            if (!dirty)
                return;
            dirty = false;
            let output = defaultOptions?.output || core.path.join(processor.config.output, 'manifest.json');
            if (!core.path.isAbsolute(output)) {
                output = core.path.resolve(process.cwd(), output);
            }
            // write to disk
            fs.writeJSONSync(output, func(this, tree, processor, defaultOptions), { spaces: 2 });
        },
    };
}

function getManifestName(path, entry) {
    // Get the string after the entry path
    const val = path.replace(entry, '');
    // Get the string after the last /{m}/
    const res = val.split('/').filter((v) => v.match(/{m}/) !== null).at(-1);
    if (!res)
        return null;
    // Split the string after the last /{m}/
    const split = val.split(res);
    // Remove the {m} from the string
    let targetPath = (split[0] + res).replace(/{(.*?)}/g, '');
    // Remove the leading and trailing /
    if (targetPath.startsWith('/'))
        targetPath = targetPath.slice(1);
    if (targetPath.endsWith('/'))
        targetPath = targetPath.slice(0, -1);
    return targetPath;
}

function pixiManifest(options) {
    const defaultOptions = {
        defaultParser: { type: 'copy', parser: defaultPixiParser },
        ...options,
    };
    const plugin = baseManifest(finish, defaultOptions);
    return plugin;
}
function finish(_plugin, tree, processor, options) {
    const bundles = new Map();
    bundles.set('default', {
        name: 'default',
        assets: [],
    });
    collect(tree, processor, bundles, options.parsers || []);
    // save bundles to a json file
    const entries = Object.fromEntries(bundles);
    const manifest = {
        bundles: Object.keys(entries).map((key) => entries[key]),
    };
    return manifest;
}
function collect(tree, processor, bundles, parsers) {
    const targetPath = getManifestName(tree.path, processor.config.entry) || 'default';
    if (!bundles.has(targetPath)) {
        bundles.set(targetPath, {
            name: targetPath,
            assets: [],
        });
    }
    const bundle = bundles.get(targetPath);
    let found = false;
    if (tree.transformed.length > 0) {
        let result = [];
        parsers.forEach((parser) => {
            if (parser.type !== core.SavableAssetCache.get(tree.path).transformData.type)
                return;
            result = parser.parser(tree, processor);
            found = true;
        });
        if (!found) {
            result = parsers?.find((parser) => parser.type === 'copy')?.parser(tree, processor);
        }
        result.forEach((entry) => {
            if (!entry.data?.tags && (Object.keys(tree.fileTags).length > 0 || Object.keys(tree.pathTags).length > 0)) {
                entry.data = entry.data || {};
                entry.data.tags = {
                    ...tree.fileTags,
                    ...tree.pathTags,
                };
            }
        });
        bundle.assets.push(...result);
    }
    bundles.set(targetPath, bundle);
    // nothing was copied or created..
    for (const i in tree.files) {
        collect(tree.files[i], processor, bundles, parsers);
    }
}
function defaultPixiParser(tree, processor) {
    const transformData = core.SavableAssetCache.get(tree.path).transformData;
    const res = transformData.files.map((file) => ({
        name: processor.trimOutputPath(file.name ?? file.paths[0]),
        srcs: file.paths.map((path) => processor.trimOutputPath(path)),
    }));
    return res;
}

exports.baseManifest = baseManifest;
exports.defaultPixiParser = defaultPixiParser;
exports.getManifestName = getManifestName;
exports.pixiManifest = pixiManifest;
//# sourceMappingURL=index.js.map
