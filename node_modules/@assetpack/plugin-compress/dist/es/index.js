import { checkExt, hasTag } from '@assetpack/core';
import sharp from 'sharp';

async function sharpCompress(type, data) {
    const { input, processor, tree, compression, output } = data;
    const res = await sharp(input)[type]({ ...compression, force: true }).toBuffer();
    processor.saveToOutput({
        tree,
        outputOptions: {
            outputData: res,
            outputPathOverride: output ?? input,
        },
    });
}

// converts png, jpg, jpeg
function compressPng(options) {
    const defaultOptions = {
        compression: {
            quality: 80,
            ...options?.compression
        },
        tags: {
            nc: 'nc'
        }
    };
    return {
        folder: false,
        test(tree, _p, opts) {
            const tags = { ...defaultOptions.tags, ...opts.tags };
            return checkExt(tree.path, '.png') && !hasTag(tree, 'path', tags.nc);
        },
        async post(tree, processor, options) {
            const pngOpts = {
                ...defaultOptions.compression,
                ...options?.compression
            };
            const input = tree.path;
            try {
                await sharpCompress('png', { input, processor, tree, compression: pngOpts });
            }
            catch (error) {
                throw new Error(`[compressPng] Failed to compress png: ${input} - ${error.message}`);
            }
        }
    };
}

function compressJpg(options) {
    const defaultOptions = {
        compression: {
            ...options?.compression
        },
        tags: {
            nc: 'nc'
        }
    };
    return {
        folder: false,
        test(tree, _p, opts) {
            const tags = { ...defaultOptions.tags, ...opts.tags };
            return checkExt(tree.path, '.jpg', '.jpeg') && !hasTag(tree, 'path', tags.nc);
        },
        async post(tree, processor, options) {
            const jpgOptions = {
                ...defaultOptions.compression,
                ...options.compression,
            };
            const input = tree.path;
            try {
                await sharpCompress('jpeg', { input, processor, tree, compression: jpgOptions });
            }
            catch (error) {
                throw new Error(`[compressJpg] Failed to compress jpg: ${input} - ${error.message}`);
            }
        }
    };
}

// converts png, jpg, jpeg
function compressWebp(options) {
    const defaultOptions = {
        compression: {
            quality: 80,
            ...options?.compression
        },
        tags: {
            nc: 'nc'
        }
    };
    return {
        folder: false,
        test(tree, _p, opts) {
            const tags = { ...defaultOptions.tags, ...opts.tags };
            return checkExt(tree.path, '.png', '.jpg', '.jpeg') && !hasTag(tree, 'path', tags.nc);
        },
        async post(tree, processor, options) {
            const webpOpts = {
                ...defaultOptions.compression,
                ...options?.compression
            };
            const input = tree.path;
            const output = tree.path.replace(/\.(png|jpg|jpeg)$/i, '.webp');
            try {
                await sharpCompress('webp', { input, processor, tree, compression: webpOpts, output });
            }
            catch (error) {
                throw new Error(`[compressWebp] Failed to compress file to webp: ${input} - ${error.message}`);
            }
        }
    };
}

export { compressJpg, compressPng, compressWebp, sharpCompress };
//# sourceMappingURL=index.js.map
