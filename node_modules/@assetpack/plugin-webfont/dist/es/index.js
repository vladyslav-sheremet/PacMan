import { checkExt, hasTag, path, SavableAssetCache } from '@assetpack/core';
import fs from 'fs-extra';
import otf2svg from 'otf2svg';
import svg2ttf from 'svg2ttf';
import ttf2woff2 from 'ttf2woff2';

const fonts = {
    ttf: {
        to: {
            woff2: (inFile) => {
                if (Buffer.isBuffer(inFile)) {
                    return ttf2woff2(inFile);
                }
                return ttf2woff2(fs.readFileSync(inFile));
            }
        },
    },
    svg: {
        to: {
            ttf: (inFile) => {
                if (inFile.startsWith('<')) {
                    return Buffer.from(svg2ttf(inFile).buffer);
                }
                return Buffer.from(svg2ttf(fs.readFileSync(inFile, 'utf8'), {}).buffer);
            },
            woff2: (inFile) => {
                // Convert SVG to TTF
                const res = fonts.svg.to.ttf(inFile);
                // Convert TTF to WOFF/WOFF2
                return fonts.ttf.to.woff2(res);
            },
        },
    },
    otf: {
        to: {
            svg: (inFile) => {
                const res = otf2svg.convert(inFile);
                return res;
            },
            ttf: (inFile) => {
                // Convert to SVG, the only format possible for otf
                const res = fonts.otf.to.svg(inFile);
                // Convert SVG to TTF
                return fonts.svg.to.ttf(res);
            },
            woff2: (inFile) => {
                // Convert to SVG, the only format possible for otf
                let res = fonts.otf.to.svg(inFile);
                // Convert SVG to TTF
                res = fonts.svg.to.ttf(res);
                // Convert TTF to WOFF/WOFF2
                return fonts.ttf.to.woff2(res);
            },
        },
    }
};

function webfont(options) {
    const defaultOptions = {
        tags: {
            font: 'font',
            ...options?.tags
        },
    };
    return {
        folder: false,
        name: 'webfont',
        test(tree, _p, options) {
            const opts = { ...defaultOptions.tags, ...options.tags };
            return checkExt(tree.path, '.otf', '.ttf') || (checkExt(tree.path, '.svg') && hasTag(tree, 'file', opts.font));
        },
        async transform(tree, processor) {
            const ext = path.extname(tree.path);
            const input = tree.path;
            const output = processor.inputToOutput(input, '.woff2');
            let res = null;
            switch (ext) {
                case '.otf':
                    res = fonts.otf.to.woff2(input);
                    break;
                case '.ttf':
                    res = fonts.ttf.to.woff2(input);
                    break;
                case '.svg':
                    res = fonts.svg.to.woff2(input);
                    break;
            }
            processor.addToTreeAndSave({
                tree,
                outputOptions: {
                    outputPathOverride: output,
                    outputData: res
                },
                transformOptions: {
                    transformId: 'webfont',
                }
            });
            SavableAssetCache.set(tree.path, {
                tree,
                transformData: {
                    type: this.name,
                    files: [{
                            name: processor.trimOutputPath(processor.inputToOutput(tree.path)),
                            paths: [output]
                        }]
                }
            });
        }
    };
}

export { webfont };
//# sourceMappingURL=index.js.map
