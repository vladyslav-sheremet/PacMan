'use strict';

var clone = require('clone');
var fs = require('fs-extra');
var merge$1 = require('merge');
var minimatch = require('minimatch');
var hash = require('object-hash');
var upath = require('upath');
var chalk = require('chalk');
var ora = require('ora');
var readline = require('readline');
var stringWidth = require('string-width');
var stripAnsi = require('strip-ansi');
var termSize = require('term-size');
var runner = require('@pixi/runner');

const defaultConfig = {
    entry: './static',
    output: './dist',
    ignore: [],
    cache: true,
    logLevel: 'info',
    plugins: {},
    files: []
};

var LogLevels;
(function (LogLevels) {
    LogLevels[LogLevels["none"] = 0] = "none";
    LogLevels[LogLevels["error"] = 1] = "error";
    LogLevels[LogLevels["warn"] = 2] = "warn";
    LogLevels[LogLevels["info"] = 3] = "info";
    LogLevels[LogLevels["verbose"] = 4] = "verbose";
})(LogLevels || (LogLevels = {}));

let terminalSize = termSize();
process.stdout.on('resize', () => {
    terminalSize = termSize();
});
function countLines(message) {
    const { columns } = terminalSize;
    return stripAnsi(message)
        .split('\n')
        .reduce((p, line) => p + Math.ceil((stringWidth(line) || 1) / columns), 0);
}
function prettifyTime(timeInMs) {
    return timeInMs < 1000 ? `${timeInMs}ms` : `${(timeInMs / 1000).toFixed(2)}s`;
}

const stdout = process.stdout;
const stderr = process.stderr;
// Some state so we clear the output properly
let lineCount = 0;
let errorLineCount = 0;
const spinner = ora({
    color: 'green',
    stream: stdout,
    discardStdin: false,
    spinner: {
        interval: 120,
        frames: ['◐', '◓', '◑', '◒']
    }
});
const persistedMessages = [];
function writeOut(message, isError = false) {
    const processedMessage = `${message}\n`;
    const hasSpinner = spinner.isSpinning;
    // Stop spinner so we don't duplicate it
    if (hasSpinner) {
        spinner.stop();
    }
    const lines = countLines(message);
    if (isError) {
        stderr.write(processedMessage);
        errorLineCount += lines;
    }
    else {
        stdout.write(processedMessage);
        lineCount += lines;
    }
    // Restart the spinner
    if (hasSpinner) {
        spinner.start();
    }
}
function persistMessage(message) {
    if (persistedMessages.includes(message))
        return;
    persistedMessages.push(message);
    writeOut(message);
}
function setSpinnerStatus(type, message) {
    const curMessage = spinner.text.replace(/\n$/, '');
    if (type === 'error') {
        spinner.fail(chalk.red.bold(message ?? curMessage));
    }
    else if (type === 'warn') {
        spinner.warn(chalk.yellow.bold(message ?? curMessage));
    }
    else if (type === 'success') {
        spinner.succeed(chalk.green.bold(message ?? curMessage));
    }
    else if (type === 'info') {
        spinner.info(chalk.blue.bold(message ?? curMessage));
    }
    lineCount++;
}
function updateSpinner(message) {
    spinner.text = `${message}\n`;
    if (!spinner.isSpinning) {
        spinner.start();
    }
}
function clearStream(stream, lines) {
    readline.moveCursor(stream, 0, -lines);
    readline.clearScreenDown(stream);
}
// Reset the window's state
function resetWindow() {
    clearStream(stderr, errorLineCount);
    errorLineCount = 0;
    clearStream(stdout, lineCount);
    lineCount = 0;
    for (const m of persistedMessages) {
        writeOut(m);
    }
}

class Reporter {
    level = 'info';
    _buildTime = 0;
    // Exported only for test
    report(event) {
        const logLevelFilter = LogLevels[this.level || 'info'];
        switch (event.type) {
            case 'buildStart': {
                if (logLevelFilter < LogLevels.info) {
                    break;
                }
                this._buildTime = Date.now();
                // Clear any previous output
                resetWindow();
                persistMessage(`${chalk.blue.bold('›')} ${chalk.blue.bold(`Building: ${event.message}`)}`);
                break;
            }
            case 'buildProgress': {
                if (logLevelFilter < LogLevels.info) {
                    break;
                }
                switch (event.phase) {
                    case 'start':
                        updateSpinner('Starting Plugins...');
                        break;
                    case 'delete':
                        setSpinnerStatus('success', 'Plugins Started');
                        updateSpinner('Cleaning Tree...');
                        break;
                    case 'transform':
                        setSpinnerStatus('success', 'Tree Cleaned');
                        updateSpinner('Transforming Assets...');
                        break;
                    case 'post':
                        setSpinnerStatus('success', 'Assets Transformed');
                        updateSpinner('Post Processing Assets...');
                        break;
                    case 'finish':
                        setSpinnerStatus('success', 'Assets Post Processed');
                        updateSpinner('Tearing Down Plugins...');
                        break;
                }
                break;
            }
            case 'buildSuccess':
                if (logLevelFilter < LogLevels.info) {
                    break;
                }
                setSpinnerStatus('success', 'Plugins Torn Down');
                resetWindow();
                persistMessage(chalk.green.bold(`› Built in: ${prettifyTime(Date.now() - this._buildTime)}`));
                break;
            case 'buildFailure':
                if (logLevelFilter < LogLevels.error) {
                    break;
                }
                resetWindow();
                setSpinnerStatus('error', chalk.red.bold('Build failed.'));
                break;
            case 'log': {
                if (logLevelFilter < LogLevels[event.level]) {
                    break;
                }
                switch (event.level) {
                    case 'verbose':
                    case 'info':
                        persistMessage(`${chalk.blue.bold('›')} Info: ${chalk.blue.bold(event.message)}`);
                        break;
                    case 'warn':
                        persistMessage(`${chalk.yellow.bold('›')} Warn: ${chalk.yellow.bold(event.message)}`);
                        break;
                    case 'error':
                        persistMessage(`${chalk.red.bold('›')} Error: ${chalk.red.bold(event.message)}`);
                        break;
                    default:
                        throw new Error(`Unknown log level ${event.level}`);
                }
            }
        }
    }
}

class LoggerClass {
    _reporter = new Reporter();
    init(config) {
        this._reporter.level = config.logLevel || 'info';
    }
    verbose(message) {
        this.report({
            type: 'log',
            level: 'verbose',
            message,
        });
    }
    log(message) {
        this.info(message);
    }
    info(message) {
        this.report({
            type: 'log',
            level: 'info',
            message,
        });
    }
    error(message) {
        this.report({
            type: 'log',
            level: 'error',
            message,
        });
    }
    warn(message) {
        this.report({
            type: 'log',
            level: 'warn',
            message,
        });
    }
    report(event) {
        this._reporter.report(event);
    }
}
const Logger = new LoggerClass();

class CacheClass {
    cache = new Map();
    /** Clear all entries. */
    reset() {
        this.cache.clear();
    }
    /**
     * Check if the key exists
     * @param key - The key to check
     */
    has(key) {
        return this.cache.has(key);
    }
    /**
     * Fetch entry by key
     * @param key - The key of the entry to get
     */
    get(key) {
        const result = this.cache.get(key);
        if (!result) {
            Logger.warn(`[Assets] Asset id ${key} was not found in the Cache`);
        }
        return result;
    }
    /**
     * Set a value by key or keys name
     * @param key - The key or keys to set
     * @param value - The value to store in the cache or from which cacheable assets will be derived.
     */
    set(key, value) {
        if (this.cache.has(key) && this.cache.get(key) !== value) {
            Logger.warn(`[Cache] already has key: ${key}`);
        }
        this.cache.set(key, value);
    }
    /**
     * Remove entry by key
     *
     * This function will also remove any associated alias from the cache also.
     * @param key - The key of the entry to remove
     */
    remove(key) {
        if (!this.cache.has(key)) {
            Logger.warn(`[Assets] Asset id ${key} was not found in the Cache`);
            return;
        }
        this.cache.delete(key);
    }
    log() {
        Logger.info(`[Cache] Cache size: ${this.cache.size}`);
        Logger.info(`[Cache] Cache keys: ${Array.from(this.cache.keys()).join(', ')}`);
        Logger.info(`[Cache] Cache values: ${Array.from(this.cache.values()).join(', ')}`);
    }
}
const SavableAssetCache = new CacheClass();

/**
 * A function that checks if the tree has the tags.
 * @param tree - The tree to be checked.
 * @param type - Whether to search the for local or global tags on the path
 * @param tags - The tags to be checked.
 * @returns If the tree has the tags.
 */
function hasTag(tree, type, ...tags) {
    if (type === 'file') {
        return tags.some((tag) => !!tree.fileTags[tag]);
    }
    return tags.some((tag) => !!tree.fileTags[tag] || !!(tree.pathTags?.[tag]));
}
function replaceExt(path, ext) {
    if (typeof path !== 'string') {
        return path;
    }
    if (path.length === 0) {
        return path;
    }
    const nFileName = upath.basename(path, upath.extname(path)) + ext;
    const nFilepath = upath.joinSafe(upath.dirname(path), nFileName);
    // Because `path.join` removes the head './' from the given path.
    // This removal can cause a problem when passing the result to `require` or
    // `import`.
    if (startsWithSingleDot(path)) {
        return `./${nFilepath}`;
    }
    return nFilepath;
}
function checkExt(path, ...ext) {
    if (typeof path !== 'string') {
        return false;
    }
    if (path.length === 0) {
        return false;
    }
    if (ext.length === 0) {
        return true;
    }
    const extname = upath.extname(path).toLowerCase();
    return ext.some((e) => e.toLowerCase() === extname);
}
function startsWithSingleDot(path) {
    const first2chars = path.slice(0, 2);
    return first2chars === './';
}
const path = upath;
const merge = merge$1;

class Processor {
    _config;
    _pluginMap = new Map();
    /** Array of plugins to be called */
    _plugins = [];
    /**  A runner that calls the start function of a plugin */
    _onStart = new runner.Runner('start');
    /** A runner that calls the finish function of a plugin */
    _onFinish = new runner.Runner('finish');
    /** Time a tree was modified */
    _modifiedTime = 0;
    _transformHash = {};
    _hash = {};
    constructor(config) {
        this._config = config;
    }
    get config() {
        return this._config;
    }
    addPlugin(plugin, key) {
        if (plugin.transform && !plugin.name) {
            throw new Error('Plugin must have a name if it has a transform function');
        }
        this._pluginMap.set(plugin, key);
        this._plugins.push(plugin);
        this._onStart.add(plugin);
        this._onFinish.add(plugin);
    }
    async run(tree) {
        this._modifiedTime = Date.now();
        tree.state = 'modified';
        Logger.report({
            type: 'buildStart',
            message: this._config.entry,
        });
        Logger.report({
            type: 'buildProgress',
            phase: 'start',
        });
        // step 1: first let all plugins know that we have begun..
        // this gets called ONCE for each plugin
        this._onStart.emit(tree, this);
        Logger.report({
            type: 'buildProgress',
            phase: 'delete',
        });
        // step 2: run all plugins
        // this loops through and deletes any output files
        // that have been deleted from input folder
        await Promise.all(this._cleanTree(tree).map((p) => p.catch((e) => {
            Logger.error(`[processor] Clean failed: ${e.message}`);
        })));
        Logger.report({
            type: 'buildProgress',
            phase: 'transform',
        });
        // step 3: next we transform our files
        // this is where one file can become another (or multiple!)
        // eg tps folder becomes a json + png file
        // all transformed files are attached to the tree node as an array
        // call 'transformed'
        // if there is no transform for a particular item then the
        // file is simply copied and stored in the transformed
        await Promise.all(this._transformTree(tree).map((p) => p.catch((e) => {
            Logger.error(`[processor] Transform failed: ${e.message}`);
        })));
        Logger.report({
            type: 'buildProgress',
            phase: 'post',
        });
        // step 4: this will do a pass on all transformed files
        // An opportunity to compress files or build manifests
        await Promise.all(this._postTree(tree).map((p) => p.catch((e) => {
            Logger.error(`[processor] Post Transform failed: ${e.message}`);
        })));
        Logger.report({
            type: 'buildProgress',
            phase: 'finish',
        });
        // now everything is done, we let all processes know that is the case.
        this._onFinish.emit(tree, this);
        Logger.report({
            type: 'buildSuccess',
        });
    }
    inputToOutput(inputPath, extension) {
        const targetPath = inputPath.replace(/{(.*?)}/g, '');
        let output = targetPath.replace(this._config.entry, this._config.output);
        if (extension) {
            output = replaceExt(output, extension);
        }
        return output;
    }
    trimOutputPath(outputPath) {
        const res = outputPath.replace(this.config.output, '');
        if (res.startsWith('/')) {
            return res.substring(1);
        }
        return res;
    }
    addToTreeAndSave(data) {
        const outputName = data.outputOptions?.outputPathOverride
            ?? this.inputToOutput(data.tree.path, data.outputOptions?.outputExtension);
        this.addToTree({
            tree: data.tree,
            outputOptions: {
                outputPathOverride: outputName,
            },
            ...data.transformOptions
        });
        this.saveToOutput({
            tree: data.tree,
            outputOptions: {
                outputPathOverride: outputName,
                outputData: data.outputOptions?.outputData,
            },
        });
    }
    saveToOutput(data) {
        const outputName = data.outputOptions?.outputPathOverride
            ?? this.inputToOutput(data.tree.path, data.outputOptions?.outputExtension);
        if (!data.outputOptions?.outputData) {
            fs.copySync(data.tree.path, outputName);
            Logger.verbose(`[processor] File Copied: ${outputName}`);
            return outputName;
        }
        fs.outputFileSync(outputName, data.outputOptions.outputData);
        Logger.verbose(`[processor] File Saved: ${outputName}`);
        return outputName;
    }
    /**
     * Adds files that have been transformed into the tree.
     *
     * @param data.outputName - Path of the file.
     * @param data.tree - Tree that will have transformed files added too.
     * @param data.isFolder - Whether transformed file is a folder.
     * @param data.fileTags - Tags that are associated with the folder.
     * @param data.transformId - Unique id for the transformed file.
     * @param data.transformData - any optional data you want to pass in with the transform.
     */
    addToTree(data) {
        // eslint-disable-next-line prefer-const
        let { tree, isFolder, fileTags, transformId, transformData } = data;
        const outputName = data.outputOptions?.outputPathOverride
            ?? this.inputToOutput(data.tree.path, data.outputOptions?.outputExtension);
        if (!tree.transformed) {
            tree.transformed = [];
        }
        isFolder = isFolder ?? tree.isFolder;
        fileTags = { ...tree.fileTags, ...fileTags };
        const treeData = {
            path: outputName,
            isFolder,
            creator: tree.path,
            time: this._modifiedTime,
            fileTags,
            pathTags: tree.pathTags,
            transformId: transformId ?? null,
            transformData: transformData || {},
        };
        tree.transformed.push(treeData);
    }
    /**
     * Recursively checks for the deleted state of the files in a tree.
     * If found then its removed from the tree and plugin.delete() is called.
     * @param tree - Tree to be processed.
     * @param promises - Array of plugin.delete promises to be returned.
     */
    _cleanTree(tree, promises = []) {
        for (const i in tree.files) {
            this._cleanTree(tree.files[i], promises);
        }
        if (tree.state === 'deleted') {
            for (let j = 0; j < this._plugins.length; j++) {
                const plugin = this._plugins[j];
                if (plugin.delete
                    && !hasTag(tree, 'path', 'ignore')
                    && plugin.test(tree, this, this.getOptions(tree.path, plugin))) {
                    promises.push(plugin.delete(tree, this, this.getOptions(tree.path, plugin)));
                }
            }
            const transformed = tree.transformed;
            if (transformed) {
                transformed.forEach((out) => {
                    fs.removeSync(out.path);
                });
                SavableAssetCache.remove(tree.path);
                this._transformHash[tree.path] = null;
            }
        }
        return promises;
    }
    /**
     * Recursively loops through a tree and called the transform function on a plugin if the tree was added or modified
     * @param tree - Tree to be processed
     * @param promises - Array of plugin.transform promises to be returned.
     */
    _transformTree(tree, promises = []) {
        let stopProcessing = false;
        let transformed = false;
        // first apply transforms / copy to other place..
        if (tree.state === 'modified' || tree.state === 'added') {
            if (tree.path && !fs.existsSync(tree.path)) {
                Logger.error(`[processor] Asset ${tree.path} does not exist. Could have been deleted half way through processing.`);
                return promises;
            }
            for (let j = 0; j < this._plugins.length; j++) {
                const plugin = this._plugins[j];
                if (plugin.transform
                    && !hasTag(tree, 'path', 'ignore')
                    && plugin.test(tree, this, this.getOptions(tree.path, plugin))) {
                    transformed = true;
                    promises.push(plugin.transform(tree, this, this.getOptions(tree.path, plugin)));
                    if (plugin.folder) {
                        stopProcessing = true;
                    }
                }
            }
            // if tree.path is nul the this is the root..
            if (!transformed) {
                if (!tree.isFolder) {
                    this.addToTreeAndSave({ tree });
                    SavableAssetCache.set(tree.path, {
                        tree,
                        transformData: {
                            type: 'copy',
                            files: [{
                                    name: this.trimOutputPath(this.inputToOutput(tree.path)),
                                    paths: [this.trimOutputPath(this.inputToOutput(tree.path))],
                                }],
                        }
                    });
                }
            }
        }
        this._hash[tree.path] = tree;
        if (tree.transformed.length > 0) {
            this._transformHash[tree.path] = tree.transformed;
        }
        else {
            tree.transformed = this._transformHash[tree.path] || [];
        }
        if (stopProcessing)
            return promises;
        for (const i in tree.files) {
            this._transformTree(tree.files[i], promises);
        }
        return promises;
    }
    /**
     * Recursively loops through a tree and called the test and post function on a process if the tree was added or modified
     * @param tree - Tree to be processed.
     * @param promises - Array of plugin.post promises to be returned.
     */
    _postTree(tree, promises = []) {
        let stopProcessing = false;
        // first apply transforms / copy to other place..
        if (tree.state === 'modified' || tree.state === 'added') {
            if (tree.transformed) {
                for (let i = 0; i < tree.transformed.length; i++) {
                    const processList = [];
                    const outfile = tree.transformed[i];
                    for (let j = 0; j < this._plugins.length; j++) {
                        const plugin = this._plugins[j];
                        if (plugin.post
                            && !hasTag(tree, 'path', 'ignore')
                            && plugin.test(tree, this, this.getOptions(tree.path, plugin))) {
                            processList.push(plugin);
                            if (plugin.folder) {
                                stopProcessing = true;
                            }
                        }
                    }
                    promises.push(new Promise(async (resolve, reject) => {
                        for (let j = 0; j < processList.length; j++) {
                            const plugin = processList[j];
                            try {
                                await plugin.post?.(outfile, this, this.getOptions(tree.path, plugin));
                            }
                            catch (error) {
                                reject(error);
                            }
                        }
                        resolve();
                    }));
                }
            }
        }
        if (stopProcessing)
            return promises;
        for (const i in tree.files) {
            this._postTree(tree.files[i], promises);
        }
        return promises;
    }
    getOptions(file, plugin) {
        let options = {};
        // walk through the config.files and see if we have a match..
        for (const i in this._config.files) {
            const fileConfig = this._config.files[i];
            // use minimatch to see if we have a match on any item in the files array
            const match = fileConfig.files.some((item) => minimatch(file, item));
            if (match) {
                options = merge$1.recursive(options, fileConfig.settings);
            }
        }
        const name = this._pluginMap.get(plugin);
        if (!name)
            throw new Error(`[processor] Plugin not found in map.`);
        return options[name] || {};
    }
}

class AssetPack {
    config;
    /** A hash of all tree nodes */
    _treeHash = {};
    /** A hash of file locations to be ignored */
    _ignoreHash = {};
    /** The current tree */
    _tree = {};
    /** The cached tree */
    _cachedTree = {};
    /** Path to store the cached tree */
    _cacheTreePath;
    /**  Manages processes and changes in assets */
    _processor;
    /** A signature to identify the cache */
    _signature;
    constructor(config) {
        // TODO validate config
        this.config = merge$1.recursive(true, defaultConfig, config);
        this.config.entry = upath.normalizeSafe(this.config.entry);
        this.config.output = upath.normalizeSafe(this.config.output);
        this._processor = new Processor(this.config);
        Logger.init(this.config);
        // create .assetpack folder if it doesn't exist
        fs.ensureDirSync('.assetpack/');
        // creates a file name that is valid for windows and mac
        const folderTag = (`${this.config.entry}-${this.config.output}`).split('/').join('-');
        this._cacheTreePath = `.assetpack/${folderTag}}`;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { plugins, ...configWithoutPlugins } = this.config;
        this._signature = hash(configWithoutPlugins);
        this._addPlugins();
    }
    _addPlugins() {
        const { plugins } = this.config;
        if (plugins) {
            Object.keys(plugins).forEach((name) => {
                this._signature += name;
                this._processor.addPlugin(plugins[name], name);
            });
        }
    }
    async run() {
        this._loadTree();
        this._walk(this.config.entry, this._tree);
        this._compareChanges(this._cachedTree, this._tree);
        await this._processor.run(this._tree);
        this._removeDeletesFromTree(this._tree);
        if (this.config.cache) {
            const cacheData = {
                signature: this._signature,
                time: new Date().getTime() + 5000,
                tree: this._tree
            };
            fs.outputFileSync(this._cacheTreePath, JSON.stringify(cacheData, null, 4));
        }
        this._cachedTree = this._tree;
    }
    _walk(dir, branch) {
        const files = fs.readdirSync(dir);
        files.forEach((file) => {
            if (file.indexOf('.DS_Store') !== -1)
                return;
            const fullPath = upath.joinSafe(dir, file);
            const base = this.config.entry;
            const relativePath = fullPath.replace(base, '');
            // should we ignore the file based on the ignore rules provided (if any)
            if (this._shouldIgnore(relativePath))
                return;
            const fileTags = this._extractTags(upath.normalizeSafe(file));
            const pathTags = this._extractTags(fullPath);
            const stat = fs.statSync(fullPath);
            const child = {
                isFolder: stat.isDirectory(),
                parent: branch.path,
                time: stat.mtimeMs,
                fileTags,
                pathTags,
                path: fullPath,
                state: 'normal',
                files: {},
                transformed: []
            };
            this._treeHash[child.path] = child;
            if (!branch.files) {
                branch.files = {};
            }
            branch.files[fullPath] = child;
            if (child.isFolder) {
                this._walk(fullPath, child);
            }
        });
    }
    /**
     * Compares changes between two trees
     * @param tree1 - Tree to be compared
     * @param tree2 - Tree to be compared
     */
    _compareChanges(tree1, tree2) {
        if (!tree1) {
            tree2.state = 'added';
            this._markDirty(tree2);
        }
        else {
            for (const i in tree1.files) {
                if (!tree2.files[i]) {
                    tree2.files[i] = clone(tree1.files[i]);
                    this._markAsDeleted(tree2.files[i]);
                    tree2.state = 'modified';
                    this._markDirty(tree2);
                }
                else if (tree2.files[i].time !== tree1.files[i].time) {
                    tree2.files[i].state = 'modified';
                    this._markDirty(tree2.files[i]);
                }
                else {
                    // same..
                    tree2.files[i].transformed = clone(tree1.files[i].transformed);
                }
            }
        }
        for (const i in tree2.files) {
            if (tree2.files[i].state !== 'deleted') {
                this._compareChanges((tree1?.files) ? tree1.files[i] : null, tree2.files[i]);
            }
        }
    }
    _loadTree() {
        if (Object.keys(this._cachedTree).length === 0 && this.config.cache) {
            try {
                fs.ensureDirSync(this.config.output);
                const json = fs.readFileSync(this._cacheTreePath, 'utf8');
                const parsedJson = JSON.parse(json);
                if (parsedJson.signature === this._signature) {
                    Logger.info('Cache found.');
                    this._cachedTree = parsedJson.tree;
                }
                else {
                    Logger.warn('Cache found, but different setup detected. Ignoring cache and rebuilding to be safe.');
                }
            }
            catch (e) {
                Logger.warn('No Cache found.');
            }
        }
        if (!this._cachedTree) {
            fs.removeSync(this.config.output);
            fs.ensureDirSync(this.config.output);
        }
        fs.removeSync(this._cacheTreePath);
        this._tree = {
            fileTags: {},
            files: {},
            isFolder: true,
            parent: null,
            path: this.config.entry,
            state: 'normal',
            pathTags: {},
            transformed: [],
        };
    }
    /**
     * Determines whether the path should be ignored based on an array of glob patterns
     * @param relativePath - Path to be checked
     * @returns If the path should be ignored
     */
    _shouldIgnore(relativePath) {
        if (this.config.ignore.length > 0) {
            if (this._ignoreHash[relativePath] === undefined) {
                this._ignoreHash[relativePath] = this.config.ignore.reduce((current, pattern) => current || minimatch(relativePath, pattern), false);
            }
            if (this._ignoreHash[relativePath])
                return true;
        }
        return false;
    }
    /**
     * Extracts the tags from the folders name and returns an object with those tags
     * @param fileName - Name of folder
     * @returns An object of tags associated with the folder
     */
    _extractTags(fileName) {
        const regEx = /{(.*?)}/g;
        const tagMatches = fileName.match(regEx);
        const values = {};
        if (tagMatches) {
            tagMatches.forEach((i) => {
                const trim = i.substring(1, i.length - 1);
                values[trim] = true;
            });
        }
        // need to loop from the files from the config and see if they have any tags to override
        if (this.config.files) {
            this.config.files.forEach((file) => {
                const { tags, files } = file;
                if (!tags)
                    return;
                const found = files.find((f) => minimatch(fileName, f));
                if (found) {
                    tags.forEach((key) => {
                        // check if key is a string
                        if (typeof key === 'string') {
                            values[key] = true;
                        }
                        else {
                            values[key.name] = key.data;
                        }
                    });
                }
            });
        }
        return values;
    }
    /**
     * Modifies the state of the tree to be `modified`
     * @param tree - Tree to be made dirty
     */
    _markDirty(tree) {
        if (!tree.parent)
            return;
        const parent = this._treeHash[tree.parent];
        if (parent && parent.state === 'normal') {
            parent.state = 'modified';
            this._markDirty(parent);
        }
    }
    /**
     * Marks a tree for deletion.
     * @param tree - The tree to be marked as deleted
     */
    _markAsDeleted(tree) {
        tree.state = 'deleted';
        for (const i in tree.files) {
            this._markAsDeleted(tree.files[i]);
        }
    }
    /**
     * Removes deleted files from the cached tree.
     * @param tree - Tree that the files will be removed from.
     */
    _removeDeletesFromTree(tree) {
        for (const i in tree.files) {
            if (tree.files[i].state === 'deleted') {
                delete tree.files[i];
            }
            else {
                this._removeDeletesFromTree(tree.files[i]);
            }
        }
    }
}

exports.AssetPack = AssetPack;
exports.Logger = Logger;
exports.Processor = Processor;
exports.SavableAssetCache = SavableAssetCache;
exports.checkExt = checkExt;
exports.defaultConfig = defaultConfig;
exports.hasTag = hasTag;
exports.merge = merge;
exports.path = path;
exports.replaceExt = replaceExt;
//# sourceMappingURL=index.js.map
