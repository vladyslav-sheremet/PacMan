import upath from 'upath';
import internalMerge from 'merge';

declare enum LogLevels {
    none = 0,
    error = 1,
    warn = 2,
    info = 3,
    verbose = 4
}

interface SaveOptions<T extends RootTree | TransformedTree> {
    tree: T;
    outputOptions?: {
        outputExtension?: string;
        outputPathOverride?: string;
        outputData?: any;
    };
    transformOptions?: {
        isFolder?: boolean;
        fileTags?: Tags;
        transformId?: string;
        transformData?: Record<string, string>;
    };
}
declare class Processor {
    private readonly _config;
    private _pluginMap;
    /** Array of plugins to be called */
    private readonly _plugins;
    /**  A runner that calls the start function of a plugin */
    private readonly _onStart;
    /** A runner that calls the finish function of a plugin */
    private readonly _onFinish;
    /** Time a tree was modified */
    private _modifiedTime;
    private _transformHash;
    private _hash;
    constructor(config: ReqAssetPackConfig);
    get config(): ReqAssetPackConfig;
    addPlugin(plugin: Plugin, key: string): void;
    run(tree: RootTree): Promise<void>;
    inputToOutput(inputPath: string, extension?: string): string;
    trimOutputPath(outputPath: string): string;
    addToTreeAndSave(data: SaveOptions<RootTree>): void;
    saveToOutput(data: Omit<SaveOptions<RootTree | TransformedTree>, 'transformOptions'>): string;
    /**
     * Adds files that have been transformed into the tree.
     *
     * @param data.outputName - Path of the file.
     * @param data.tree - Tree that will have transformed files added too.
     * @param data.isFolder - Whether transformed file is a folder.
     * @param data.fileTags - Tags that are associated with the folder.
     * @param data.transformId - Unique id for the transformed file.
     * @param data.transformData - any optional data you want to pass in with the transform.
     */
    addToTree(data: Omit<SaveOptions<RootTree>, 'transformOptions'> & SaveOptions<RootTree>['transformOptions']): void;
    /**
     * Recursively checks for the deleted state of the files in a tree.
     * If found then its removed from the tree and plugin.delete() is called.
     * @param tree - Tree to be processed.
     * @param promises - Array of plugin.delete promises to be returned.
     */
    private _cleanTree;
    /**
     * Recursively loops through a tree and called the transform function on a plugin if the tree was added or modified
     * @param tree - Tree to be processed
     * @param promises - Array of plugin.transform promises to be returned.
     */
    private _transformTree;
    /**
     * Recursively loops through a tree and called the test and post function on a process if the tree was added or modified
     * @param tree - Tree to be processed.
     * @param promises - Array of plugin.post promises to be returned.
     */
    private _postTree;
    private getOptions;
}

interface PluginOptions<T extends string> {
    tags: Partial<Record<T, string>>;
}
interface Plugin<T = Record<string, any>> {
    /** Whether the process runs on a folder */
    folder: boolean;
    /** Name of the plugin used to tell the manifest parsers which one to use */
    name?: string;
    /**
     * Called once at the start.
     * @param tree -
     * @param processor - Processor that called the function.
     */
    start?(tree: RootTree, processor: Processor): void;
    /**
     * Called when tree is marked for deletion.
     * @param tree -
     * @param processor - Processor that called the function.
     */
    delete?(tree: RootTree, processor: Processor, options: T): Promise<void>;
    /**
     * Returns a boolean on whether or not the process should affect this tree.
     * @param tree - Tree to be tested.
     * @returns By defaults returns false.
     */
    test(tree: RootTree | TransformedTree, processor: Processor, options: T): boolean;
    /**
     *
     * @param tree -
     * @param processor - Processor that called the function.
     */
    transform?(tree: RootTree, processor: Processor, options: T): Promise<void>;
    /**
     * If test is passed then this is called.
     * @param tree -
     * @param processor - Processor that called the function.
     */
    post?(tree: TransformedTree, processor: Processor, options: T): Promise<void>;
    /**
     * Called once after tree has been processed.
     * @param tree -
     * @param processor - Processor that called the function.
     */
    finish?(tree: RootTree, processor: Processor): void;
}

interface AssetPackConfig {
    /** the entry point of assetpack, the folder that will be converted */
    entry?: string;
    /** the output, the converted transformed folder will be here */
    output?: string;
    /**
      * an optional array of ignore patterns. Any file path matching the patterns will not be processed by assetpack
      * they can be globs to.
      */
    ignore?: string[];
    /**
      * If true cached tree will be used
      * @defaultValue true
      */
    cache?: boolean;
    logLevel?: keyof typeof LogLevels;
    plugins?: Record<string, Plugin>;
    files?: Array<{
        files: string[];
        settings: Record<string, any>;
        tags: Array<string | {
            name: string;
            data: any;
        }>;
    }>;
}
type ReqAssetPackConfig = Required<AssetPackConfig>;
declare const defaultConfig: AssetPackConfig;

interface Tags {
    [x: string]: boolean | Array<any> | Record<string, any>;
}
interface RootTree {
    fileTags: Tags;
    pathTags: Tags;
    files: {
        [x: string]: ChildTree;
    };
    isFolder: boolean;
    parent: string | null;
    path: string;
    state: 'added' | 'deleted' | 'modified' | 'normal';
    transformed: TransformedTree[];
}
interface ChildTree extends RootTree {
    time: number;
}
interface TransformedTree extends Omit<RootTree, 'files' | 'parent' | 'transformed' | 'state'> {
    creator: string;
    time: number;
    transformId: string | null;
    transformData: Record<string, any>;
}
declare class AssetPack {
    readonly config: ReqAssetPackConfig;
    /** A hash of all tree nodes */
    private _treeHash;
    /** A hash of file locations to be ignored */
    private _ignoreHash;
    /** The current tree */
    private _tree;
    /** The cached tree */
    private _cachedTree;
    /** Path to store the cached tree */
    private readonly _cacheTreePath;
    /**  Manages processes and changes in assets */
    private readonly _processor;
    /** A signature to identify the cache */
    private _signature;
    constructor(config: AssetPackConfig);
    private _addPlugins;
    run(): Promise<void>;
    private _walk;
    /**
     * Compares changes between two trees
     * @param tree1 - Tree to be compared
     * @param tree2 - Tree to be compared
     */
    private _compareChanges;
    private _loadTree;
    /**
     * Determines whether the path should be ignored based on an array of glob patterns
     * @param relativePath - Path to be checked
     * @returns If the path should be ignored
     */
    private _shouldIgnore;
    /**
     * Extracts the tags from the folders name and returns an object with those tags
     * @param fileName - Name of folder
     * @returns An object of tags associated with the folder
     */
    private _extractTags;
    /**
     * Modifies the state of the tree to be `modified`
     * @param tree - Tree to be made dirty
     */
    private _markDirty;
    /**
     * Marks a tree for deletion.
     * @param tree - The tree to be marked as deleted
     */
    private _markAsDeleted;
    /**
     * Removes deleted files from the cached tree.
     * @param tree - Tree that the files will be removed from.
     */
    private _removeDeletesFromTree;
}

declare class CacheClass<T> {
    cache: Map<string, T>;
    /** Clear all entries. */
    reset(): void;
    /**
     * Check if the key exists
     * @param key - The key to check
     */
    has(key: string): boolean;
    /**
     * Fetch entry by key
     * @param key - The key of the entry to get
     */
    get(key: string): T;
    /**
     * Set a value by key or keys name
     * @param key - The key or keys to set
     * @param value - The value to store in the cache or from which cacheable assets will be derived.
     */
    set(key: string, value: T): void;
    /**
     * Remove entry by key
     *
     * This function will also remove any associated alias from the cache also.
     * @param key - The key of the entry to remove
     */
    remove(key: string): void;
    log(): void;
}
interface TransformDataFile {
    name?: string;
    paths: string[];
}
interface TransformData {
    type: string;
    files: TransformDataFile[];
    [x: string]: any;
}
interface CacheableAsset {
    tree: ChildTree | TransformedTree | RootTree;
    transformData: TransformData;
}
declare const SavableAssetCache: CacheClass<CacheableAsset>;

interface LogEvent {
    type: 'log';
    level: keyof typeof LogLevels;
    message: string;
}
interface BuildEvent {
    type: 'buildStart' | 'buildProgress' | 'buildSuccess' | 'buildFailure';
    phase?: 'start' | 'delete' | 'transform' | 'post' | 'finish';
    message?: string;
}
type ReporterEvent = LogEvent | BuildEvent;

declare class LoggerClass {
    private _reporter;
    init(config: AssetPackConfig): void;
    verbose(message: string): void;
    log(message: string): void;
    info(message: string): void;
    error(message: string): void;
    warn(message: string): void;
    report(event: ReporterEvent): void;
}
declare const Logger: LoggerClass;

/**
 * A function that checks if the tree has the tags.
 * @param tree - The tree to be checked.
 * @param type - Whether to search the for local or global tags on the path
 * @param tags - The tags to be checked.
 * @returns If the tree has the tags.
 */
declare function hasTag(tree: RootTree | TransformedTree, type: 'file' | 'path', ...tags: string[]): boolean;
declare function replaceExt(path: string, ext: string): string;
declare function checkExt(path: string, ...ext: string[]): boolean;
declare const path: typeof upath;
declare const merge: typeof internalMerge;

export { AssetPack, AssetPackConfig, CacheableAsset, ChildTree, Logger, Plugin, PluginOptions, Processor, ReqAssetPackConfig, RootTree, SavableAssetCache, Tags, TransformData, TransformDataFile, TransformedTree, checkExt, defaultConfig, hasTag, merge, path, replaceExt };
