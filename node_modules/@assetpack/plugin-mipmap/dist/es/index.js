import { checkExt, hasTag, SavableAssetCache } from '@assetpack/core';
import sharp from 'sharp';
import fs from 'fs-extra';

function mipmap(options) {
    const defaultOptions = {
        template: '@%%x',
        resolutions: { default: 1, low: 0.5 },
        fixedResolution: 'default',
        ...options,
        tags: {
            fix: 'fix',
            ...options?.tags
        },
    };
    return {
        folder: false,
        name: 'mipmap',
        test(tree) {
            return checkExt(tree.path, '.png', '.jpg', ',jpeg');
        },
        async transform(tree, processor, options) {
            const tags = { ...defaultOptions.tags, ...options.tags };
            const transformOptions = { ...defaultOptions, ...options };
            const largestResolution = Math.max(...Object.values(transformOptions.resolutions));
            const resolutionHash = hasTag(tree, 'path', tags.fix)
                ? {
                    default: transformOptions.resolutions[transformOptions.fixedResolution]
                }
                : transformOptions.resolutions;
            const files = [];
            // loop through each resolution and pack the images
            for (const resolution of Object.values(resolutionHash)) {
                const scale = resolution / largestResolution;
                const template = transformOptions.template.replace('%%', resolution.toString());
                let outputName = processor.inputToOutput(tree.path);
                // replace the extension with the template
                outputName = outputName.replace(/(\.[\w\d_-]+)$/i, `${template}$1`);
                const out = await processFile({
                    output: outputName,
                    input: tree.path,
                    scale,
                    processor,
                });
                processor.addToTreeAndSave({
                    tree,
                    outputOptions: {
                        outputPathOverride: outputName,
                        outputData: out
                    },
                    transformOptions: {
                        transformId: 'mipmap',
                        transformData: {
                            resolution: resolution.toString(),
                        },
                    }
                });
                files.push(processor.trimOutputPath(outputName));
            }
            SavableAssetCache.set(tree.path, {
                tree,
                transformData: {
                    type: this.name,
                    prefix: transformOptions.template,
                    resolutions: Object.values(resolutionHash),
                    files: [{
                            name: processor.trimOutputPath(processor.inputToOutput(tree.path)),
                            paths: files,
                        }]
                }
            });
        }
    };
}
async function processFile(options) {
    // now mip the file..
    const meta = await sharp(options.input).metadata().catch((e) => {
        throw new Error(`[mipmap] Could not get metadata for ${options.input}: ${e.message}`);
    });
    if (!meta.width || !meta.height) {
        throw new Error(`[mipmap] Could not get metadata for ${options.input}`);
    }
    let res;
    try {
        res = await sharp(options.input)
            .resize({
            width: Math.ceil(meta.width * options.scale),
            height: Math.ceil(meta.height * options.scale)
        })
            .toBuffer();
    }
    catch (error) {
        throw new Error(`[mipmap] Could not resize ${options.input}: ${error.message}`);
    }
    return res;
}

function spineAtlasMipmap(options) {
    const defaultOptions = {
        template: '@%%x',
        resolutions: { default: 1, low: 0.5 },
        fixedResolution: 'default',
        ...options,
        tags: {
            fix: 'fix',
            spine: 'spine',
            ...options?.tags
        },
    };
    return {
        folder: false,
        name: 'spine-atlas',
        test(tree, _p, opts) {
            const opt = { ...defaultOptions.tags, ...opts.tags };
            return hasTag(tree, 'file', opt.spine) && checkExt(tree.path, '.atlas');
        },
        async transform(tree, processor, options) {
            const tags = { ...defaultOptions.tags, ...options.tags };
            const transformOptions = { ...defaultOptions, ...options };
            const largestResolution = Math.max(...Object.values(transformOptions.resolutions));
            const resolutionHash = hasTag(tree, 'path', tags.fix)
                ? {
                    default: transformOptions.resolutions[transformOptions.fixedResolution]
                }
                : transformOptions.resolutions;
            const rawAtlas = fs.readFileSync(tree.path, 'utf8');
            const files = [];
            for (const resolution of Object.values(resolutionHash)) {
                const scale = resolution / largestResolution;
                const template = transformOptions.template.replace('%%', resolution.toString());
                const outputName = processor.inputToOutput(tree.path).replace(/(\.[\w\d_-]+)$/i, `${template}$1`);
                const out = rescaleAtlas(rawAtlas, scale, template);
                processor.addToTreeAndSave({
                    tree,
                    outputOptions: {
                        outputPathOverride: outputName,
                        outputData: out
                    },
                    transformOptions: {
                        transformId: 'spine-atlas',
                        transformData: {
                            resolution: resolution.toString(),
                        },
                    }
                });
                files.push(processor.trimOutputPath(outputName));
            }
            SavableAssetCache.set(tree.path, {
                tree,
                transformData: {
                    type: this.name,
                    prefix: transformOptions.template,
                    resolutions: Object.values(resolutionHash),
                    files: [{
                            name: processor.trimOutputPath(processor.inputToOutput(tree.path)),
                            paths: files,
                        }]
                }
            });
        }
    };
}
/**
 * Re-scale atlas raw string data to given scale
 * @param raw - Raw atlas data as string
 * @param scale - The multiplier for position and size values
 * @param template - Resolution template, same used for images
 */
function rescaleAtlas(raw, scale = 1, template = '') {
    const lines = raw.split(/\r\n|\r|\n/);
    // Regex for xy values, like 'size: 2019,463', 'orig: 134, 240'
    const reXY = /(.*?:\s?)(\d+)(\s?,\s?)(\d+)$/;
    // Regex for image names, like 'image.png', 'img.jpg'
    const reImg = /(.+)(.png|jpg|jpeg)$/;
    // eslint-disable-next-line @typescript-eslint/no-for-in-array
    for (const i in lines) {
        let line = lines[i];
        const matchXY = reXY.exec(line);
        if (matchXY) {
            // Multiply values by scale
            const x = Math.floor(Number(matchXY[2]) * scale);
            const y = Math.floor(Number(matchXY[4]) * scale);
            // Rewrite line with new values
            line = line.replace(reXY, `$1${x}$3${y}`);
        }
        if (reImg.exec(line)) {
            // Rename images using provided template
            line = line.replace(reImg, `$1${template}$2`);
        }
        lines[i] = line;
    }
    return lines.join('\n');
}

export { mipmap, spineAtlasMipmap };
//# sourceMappingURL=index.js.map
