import { ObservablePoint } from '@pixi/core';
import { Container } from '@pixi/display';
import { Text } from '@pixi/text';
import { Signal } from 'typed-signals';
import { FederatedPointerEvent } from '@pixi/events';
declare const states: readonly ["default", "hover", "pressed", "disabled"];
type State = typeof states[number];
type Pos = {
    x?: number;
    y?: number;
};
type PosList = {
    [K in State]?: Pos;
};
export type Offset = Pos & PosList;
type Views = {
    defaultView: string | Container;
    hoverView?: string | Container;
    pressedView?: string | Container;
    disabledView?: string | Container;
    text?: string | number | Text;
    icon?: string | Container;
};
type AnimationData = {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    scale?: Pos;
};
type Animation = {
    props: AnimationData;
    duration?: number;
};
type StateAnimations = {
    [K in State]?: Animation;
};
export type ButtonOptions = Views & {
    padding?: number;
    anchor?: number;
    anchorX?: number;
    anchorY?: number;
    offset?: Offset;
    textOffset?: Offset;
    iconOffset?: Offset;
    animations?: StateAnimations;
};
/**
 * Button component with a lots of tweaks, to create a button fast.
 *
 *  By default text view and icon view are centered in the active view.
 *
 * If views are not the same size, offset property of the constructor
 * can be used to adjust the position of the text, icon and the views.
 * @example
 * ```
 * const button = new Button({
 *     defaultView: `button.png`,
 *     hoverView: `button_hover.png`,
 *     pressedView: `button_pressed.png`,
 *     text: new Text('Click me!'),
 * });
 *
 * button.onPress.connect(() => console.log('Button pressed!'));
 * ```
 */
export declare class FancyButton extends Container {
    private events;
    private animations;
    private originalInnerViewState;
    /** Padding of the button text view. If button text does not fit active view + padding it will scale down to fit. */
    padding: number;
    /** Offset of the button state views. If state views have different sizes, this option can help adjust them. */
    offset: Offset & Pos;
    /** Offset of the text view. Can be set to any state of the button. */
    textOffset: Offset;
    /** Offset of the icon view. Can be set to any state of the button. */
    iconOffset: Offset;
    innerView: Container;
    /** View that is shown when non of the button events are active. */
    defaultView: Container;
    /** View that is shown when the mouse hovers over the button. */
    hoverView: Container;
    /** View, shown when the mouse press on the component. */
    pressedView: Container;
    /** View shown when the button is disabled. */
    disabledView: Container;
    /** View for the button text. */
    textView: Text;
    /** View for the button icon. */
    iconView: Container;
    /** State of the button. Possible valuers are: 'default', 'hover', 'pressed', 'disabled' */
    state: State;
    /** Anchor point of the button. */
    anchor: ObservablePoint;
    /** Event fired when the button was pressed. */
    onPress: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** Event fired when the button is down. */
    onDown: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** Event fired when the down event happens inside the button and up event happened inside or outside of the button */
    onUp: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** Event fired when a mouse hovers the button. */
    onHover: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** Event fired when a mouse leaves the button. */
    onOut: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** Event fired when the up event happens outside of the button, after the down event happened inside the button. */
    onUpOut: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    constructor({ defaultView, hoverView, pressedView, disabledView, text, padding, offset, textOffset, iconOffset, anchor, anchorX, anchorY, icon, animations }: ButtonOptions);
    /**
     * Updates the text of the button and updates its scaling basing on the new size.
     * @param {string | number} text
     */
    set text(text: string | number);
    /** Returns the text string of the button text element. */
    get text(): string;
    /**
     * Setter, that prevents all button events from firing.
     * @param {boolean} enabled
     */
    set enabled(enabled: boolean);
    /** Getter that returns button state, that controls if button events are firing. */
    get enabled(): boolean;
    /**
     * Updates button state and shows the according views.
     *
     * Updates positions and offsets of the views.
     *
     * Plays animations if they are set.
     * @param {State} newState
     */
    setState(newState: State): void;
    /**
     *
     * Manage button text view.
     * @param {string | Text} text - can be a string or a Text (Container-based element).
     */
    private createTextView;
    /**
     * Manage button icon view.
     * @param {string | Text} icon - can be a string or a Text (Container-based element).
     */
    private createIconView;
    /**
     * Manages views offsets if it's set.
     * @param view
     * @param state
     * @param offset
     */
    private setOffset;
    /**
     * Returns active view for the state.
     * @param state
     */
    private getStateView;
    /**
     * Adjusts text view position and scale.
     * @param {State} state
     */
    private adjustTextView;
    /**
     * Adjusts icon view position and scale.
     * @param {State} state
     */
    private adjustIconView;
    /**
     * Reset views positions according to the button anchor setting.
     * We have to set the anchor position for each view individually, as each of them
     * can be a different type of view (container without anchor, sprite with anchor, etc)
     * we have to reset all anchors to 0,0 and then set the positions manually.
     */
    private resetViewsPositions;
    /**
     * Button views manager. Adds or creates all button views according to the config.
     * @param {Views} views
     */
    private createViews;
    /** Creates all button events */
    private addEvents;
    /**
     * Starts animation for the current button state if configured.
     * @param {State} state
     */
    private playAnimations;
}
export {};
//# sourceMappingURL=FancyButton.d.ts.map