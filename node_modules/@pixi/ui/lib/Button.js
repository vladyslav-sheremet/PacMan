'use strict';

var core = require('@pixi/core');
var typedSignals = require('typed-signals');

class Button {
  /**
   * Turns a given container-based view into a button by adding all button events.
   * @param {Container} view - Contained-based view
   */
  constructor(view) {
    this.view = view;
    this.createEvents();
    this.enabled = true;
  }
  /**
   * Method called when the button pressed.
   * To be overridden.
   * @param {FederatedPointerEvent} _e - event data
   */
  down(_e) {
  }
  /**
   * Method called when the button is up.
   * To be overridden.
   * @param {FederatedPointerEvent} _e - event data
   */
  up(_e) {
  }
  /**
   * Method called when the mouse hovers the button.
   * To be overridden.
   * This is fired only on PC.
   * @param {FederatedPointerEvent} _e - event data
   */
  hover(_e) {
  }
  /**
   * Method called when the mouse press down the button.
   * To be overridden.
   * This is fired only on PC.
   * @param {FederatedPointerEvent} _e - event data
   */
  press(_e) {
  }
  /**
   * Method called when the mouse leaves the button.
   * To be overridden.
   * This is fired only on PC.
   * @param {FederatedPointerEvent} _e - event data
   */
  out(_e) {
  }
  /**
   * Method called when the up event happens outside of the button,
   * after the down event happened inside the button boundaries.
   * To be overridden.
   * This is fired only on PC.
   * @param {FederatedPointerEvent} _e - event data
   */
  upOut(_e) {
  }
  /** Getter that returns if the button is down. */
  get isDown() {
    return this._isDown;
  }
  /**
   * Swither, which prevents all button events from firing.
   * @param {boolean} enabled
   */
  set enabled(enabled) {
    this._enabled = enabled;
    this.view.interactive = enabled;
    this.view.cursor = enabled ? "pointer" : "default";
    if (!enabled) {
      this._processUp();
    }
  }
  /** Getter that returns button state, that controls if button events are firing. */
  get enabled() {
    return this._enabled;
  }
  _processUp(e) {
    if (this._isDown) {
      this.onUp.emit(this, e);
    }
    this._isDown = false;
  }
  _processUpOut(e) {
    if (this._isDown) {
      this.onUp.emit(this, e);
      this.onUpOut.emit(this, e);
    }
    this._isDown = false;
  }
  _processOut(e) {
    if (this._isMouseIn) {
      this._isMouseIn = false;
      this.onOut.emit(this, e);
    }
  }
  _upOut(e) {
    this.upOut(e);
  }
  _out(e) {
    this.out(e);
  }
  createEvents() {
    this.onPress = new typedSignals.Signal();
    this.onDown = new typedSignals.Signal();
    this.onUp = new typedSignals.Signal();
    this.onHover = new typedSignals.Signal();
    this.onOut = new typedSignals.Signal();
    this.onUpOut = new typedSignals.Signal();
    this.view.on("pointerdown", (e) => {
      this._isDown = true;
      this.onDown.emit(this, e);
    });
    this.view.on("pointerup", (e) => {
      this._processUp(e);
    });
    this.view.on("pointerupoutside", (e) => {
      this._processUpOut(e);
    });
    this.view.on("pointerout", (e) => {
      this._processOut(e);
    });
    this.view.on("pointertap", (e) => {
      this._isDown = false;
      this.onPress.emit(this, e);
      this.press(e);
    });
    this.view.on("pointerover", (e) => {
      this._isMouseIn = true;
      this.onHover.emit(this, e);
    });
    this.onDown.connect((_btn, e) => {
      this.down(e);
    });
    this.onUp.connect((_btn, e) => {
      this.up(e);
    });
    this.onUpOut.connect((_bth, e) => {
      this._upOut(e);
    });
    if (!core.utils.isMobile.any) {
      this.onHover.connect((_bth, e) => {
        this.hover(e);
      });
    }
    this.onOut.connect((_bth, e) => {
      this._out(e);
    });
  }
}

exports.Button = Button;
//# sourceMappingURL=Button.js.map
