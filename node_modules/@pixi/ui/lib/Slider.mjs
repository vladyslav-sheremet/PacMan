import { Signal } from 'typed-signals';
import { SliderBase } from './SliderBase.mjs';

class Slider extends SliderBase {
  constructor(options) {
    super({
      bg: options.bg,
      slider1: options.slider,
      fill: options.fill ?? "",
      min: options.min,
      max: options.max,
      value1: options.value,
      valueTextStyle: options.valueTextStyle,
      showValue: options.showValue,
      valueTextOffset: options.valueTextOffset,
      fillOffset: options.fillOffset
    });
    /** Fires when value changed, only when slider is released. */
    this.onChange = new Signal();
    /** Fires when value is changing, on every move of slider. */
    this.onUpdate = new Signal();
    this.options = options;
    this.value = options.value ?? 0;
  }
  /** Return selected value. */
  get value() {
    return this._value1;
  }
  /** Set selected value. */
  set value(value) {
    if (value === this._value1)
      return;
    if (value < this.min)
      value = this.min;
    if (value > this.max)
      value = this.max;
    this._value1 = value;
    this.progress = (this.max - this.min) / 100 * value;
    this.slider1.x = (this.bg.width - this.slider1.width) / 100 * this.progress;
    if (this.options.showValue) {
      this.value1Text.text = `${value}`;
      const sliderPosX = this.slider1.x + this.slider1.width / 2;
      const sliderPosY = this.slider1.y;
      this.value1Text.x = sliderPosX + (this.options.valueTextOffset?.x ?? 0);
      this.value1Text.y = sliderPosY + (this.options.valueTextOffset?.y ?? 0);
    }
    this.onUpdate?.emit(this.value);
  }
  update(event) {
    if (!this.dragging)
      return;
    const obj = event.currentTarget;
    const { x } = obj.parent.worldTransform.applyInverse(event.global);
    const progress = this.validate(x / this.bg.width * 100);
    if (progress !== this.progress) {
      this.value = (this.max - this.min) / 100 * progress;
    }
  }
}

export { Slider };
//# sourceMappingURL=Slider.mjs.map
