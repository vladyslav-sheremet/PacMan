'use strict';

var core = require('@pixi/core');
var display = require('@pixi/display');
var view = require('./utils/helpers/view.js');
var text = require('./utils/helpers/text.js');
var Button = require('./Button.js');
var typedSignals = require('typed-signals');
var fit = require('./utils/helpers/fit.js');
var tweedle_js = require('tweedle.js');

class FancyButton extends display.Container {
  constructor({
    defaultView,
    hoverView,
    pressedView,
    disabledView,
    text,
    padding,
    offset,
    textOffset,
    iconOffset,
    anchor,
    anchorX,
    anchorY,
    icon,
    animations
  }) {
    super();
    this.createViews({
      defaultView,
      hoverView,
      pressedView,
      disabledView,
      text,
      icon
    });
    this.anchor = new core.ObservablePoint(this.resetViewsPositions, this);
    this.anchor.set(anchorX ?? anchor ?? 0, anchorY ?? anchor ?? 0);
    this.padding = padding ?? 0;
    this.offset = offset;
    this.textOffset = textOffset;
    this.iconOffset = iconOffset;
    if (animations) {
      this.animations = animations;
      core.Ticker.shared.add(() => tweedle_js.Group.shared.update());
    }
    this.setState("default");
    this.addEvents();
  }
  /**
   * Updates the text of the button and updates its scaling basing on the new size.
   * @param {string | number} text
   */
  set text(text) {
    if (!this.textView) {
      this.createTextView(typeof text === "number" ? text.toString() : text);
    }
    this.textView.text = text;
    this.setState(this.state);
    this.adjustTextView(this.state);
  }
  /** Returns the text string of the button text element. */
  get text() {
    return this.textView?.text;
  }
  /**
   * Setter, that prevents all button events from firing.
   * @param {boolean} enabled
   */
  set enabled(enabled) {
    this.events.enabled = enabled;
    this.setState(enabled ? "default" : "disabled");
  }
  /** Getter that returns button state, that controls if button events are firing. */
  get enabled() {
    return this.events.enabled;
  }
  /**
   * Updates button state and shows the according views.
   *
   * Updates positions and offsets of the views.
   *
   * Plays animations if they are set.
   * @param {State} newState
   */
  setState(newState) {
    if (this.state === newState) {
      return;
    }
    const currentView = this.getStateView(this.state);
    const activeView = this.getStateView(newState);
    currentView.visible = false;
    activeView.visible = true;
    this.state = newState;
    this.setOffset(activeView, newState, this.offset);
    this.adjustTextView(newState);
    this.adjustIconView(newState);
    this.playAnimations(newState);
  }
  /**
   *
   * Manage button text view.
   * @param {string | Text} text - can be a string or a Text (Container-based element).
   */
  createTextView(text$1) {
    this.textView = text.getTextView(text$1);
    this.textView.anchor.set(0);
  }
  /**
   * Manage button icon view.
   * @param {string | Text} icon - can be a string or a Text (Container-based element).
   */
  createIconView(icon) {
    this.iconView = view.getView(icon);
  }
  /**
   * Manages views offsets if it's set.
   * @param view
   * @param state
   * @param offset
   */
  setOffset(view, state, offset) {
    const stateOffset = offset ? offset[state] : {
      x: 0,
      y: 0
    };
    const defaultStateOffset = offset?.default;
    if (stateOffset) {
      view.x += stateOffset.x ?? 0;
      view.y += stateOffset.y ?? 0;
    } else if (defaultStateOffset) {
      view.x += defaultStateOffset.x ?? 0;
      view.y += defaultStateOffset.y ?? 0;
    } else if (offset.x || offset.y) {
      view.x += offset.x ?? 0;
      view.y += offset.y ?? 0;
    }
  }
  /**
   * Returns active view for the state.
   * @param state
   */
  getStateView(state) {
    switch (state) {
      case "hover":
        return this.hoverView ?? this.defaultView;
      case "pressed":
        return this.pressedView ?? this.defaultView;
      case "disabled":
        return this.disabledView ?? this.defaultView;
      case "default":
      default:
        return this.defaultView;
    }
  }
  /**
   * Adjusts text view position and scale.
   * @param {State} state
   */
  adjustTextView(state) {
    if (!this.textView) {
      return;
    }
    const activeView = this.getStateView(this.state);
    fit.fitToView(activeView, this.textView, this.padding);
    activeView.addChild(this.textView);
    this.textView.x = (activeView.width - this.textView.width) / 2;
    this.textView.y = (activeView.height - this.textView.height) / 2;
    this.setOffset(this.textView, state, this.textOffset);
  }
  /**
   * Adjusts icon view position and scale.
   * @param {State} state
   */
  adjustIconView(state) {
    if (!this.iconView) {
      return;
    }
    const activeView = this.getStateView(this.state);
    fit.fitToView(activeView, this.iconView, this.padding);
    activeView.addChild(this.iconView);
    this.iconView.x = activeView.width / 2 - this.iconView.width / 2;
    this.iconView.y = activeView.height / 2 - this.iconView.height / 2;
    this.setOffset(this.iconView, state, this.iconOffset);
  }
  /**
   * Reset views positions according to the button anchor setting.
   * We have to set the anchor position for each view individually, as each of them
   * can be a different type of view (container without anchor, sprite with anchor, etc)
   * we have to reset all anchors to 0,0 and then set the positions manually.
   */
  resetViewsPositions() {
    const anchorX = this.anchor?.x ?? 0;
    const anchorY = this.anchor?.y ?? 0;
    const views = [this.defaultView, this.hoverView, this.pressedView, this.disabledView];
    views.forEach((view) => {
      if (!view)
        return;
      view.anchor?.set(0);
      view.x = -view.width * anchorX;
      view.y = -view.height * anchorY;
    });
  }
  /**
   * Button views manager. Adds or creates all button views according to the config.
   * @param {Views} views
   */
  createViews(views) {
    const { defaultView, hoverView, pressedView, disabledView, text, icon } = views;
    this.innerView = new display.Container();
    this.addChild(this.innerView);
    this.defaultView = view.getView(defaultView);
    this.innerView.addChild(this.defaultView);
    if (hoverView) {
      this.hoverView = view.getView(hoverView);
      this.innerView.addChild(this.hoverView);
      this.hoverView.visible = false;
    }
    if (pressedView) {
      this.pressedView = view.getView(pressedView);
      this.innerView.addChild(this.pressedView);
      this.pressedView.visible = false;
    }
    if (disabledView) {
      this.disabledView = view.getView(disabledView);
      this.innerView.addChild(this.disabledView);
      this.disabledView.visible = false;
    }
    if (text) {
      this.createTextView(text);
    }
    if (icon) {
      this.createIconView(icon);
    }
  }
  /** Creates all button events */
  addEvents() {
    this.events = new Button.Button(this);
    this.onPress = new typedSignals.Signal();
    this.onDown = new typedSignals.Signal();
    this.onUp = new typedSignals.Signal();
    this.onHover = new typedSignals.Signal();
    this.onOut = new typedSignals.Signal();
    this.onUpOut = new typedSignals.Signal();
    this.events.onPress.connect((_bth, e) => {
      this.onPress.emit(this, e);
      this.setState("hover");
    });
    this.events.onDown.connect((_bth, e) => {
      this.onDown.emit(this, e);
      this.setState("pressed");
    });
    this.events.onUp.connect((_bth, e) => {
      this.onUp.emit(this, e);
      this.setState("hover");
    });
    this.events.onHover.connect((_bth, e) => {
      this.onHover.emit(this, e);
      this.setState("hover");
    });
    this.events.onOut.connect((_bth, e) => {
      this.onOut.emit(this, e);
      this.setState("default");
    });
    this.events.onUpOut.connect((_bth, e) => {
      this.onUpOut.emit(this, e);
      this.setState("default");
    });
  }
  /**
   * Starts animation for the current button state if configured.
   * @param {State} state
   */
  playAnimations(state) {
    if (!this.originalInnerViewState) {
      this.originalInnerViewState = {
        x: this.innerView.x,
        y: this.innerView.y,
        width: this.innerView.width,
        height: this.innerView.height,
        scale: {
          x: this.innerView.scale.x,
          y: this.innerView.scale.y
        }
      };
    }
    if (this.animations && this.animations[state]) {
      const data = this.animations[state];
      new tweedle_js.Tween(this.innerView).to(data.props, data.duration).start();
    } else if (this.animations && state === "default") {
      new tweedle_js.Tween(this.innerView).to(this.originalInnerViewState, 100).start();
    }
  }
}

exports.FancyButton = FancyButton;
//# sourceMappingURL=FancyButton.js.map
