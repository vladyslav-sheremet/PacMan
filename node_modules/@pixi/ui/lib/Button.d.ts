import { Container } from '@pixi/display';
import { FederatedPointerEvent } from '@pixi/events';
import { Signal } from 'typed-signals';
/**
 * Adds button events to a given container-based view
 *
 * so you can subscribe to them and use your container-based instance as a button.
 * @example
 * ```
 * const container = new Container();
 * const button = new Button(
 *      new Graphics()
 *          .beginFill(0xFFFFFF)
 *          .drawRoundedRect(0, 0, 100, 50, 15)
 * );
 *
 * buttonEvents.onPress.connect(() => console.log('onPress'));
 *
 * container.addChild(buttonEvents.view);
 * ```
 */
export declare class Button {
    /** Container, given as a constructor parameter that is a button view. */
    view: Container;
    /** Event that is fired when the button is pressed. */
    onPress: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** Event that is fired when the button is down. */
    onDown: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /**
     * Event that fired when a down event happened inside the button
     * and up event happened inside or outside of the button
     */
    onUp: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** Event that is fired when the mouse hovers the button. */
    onHover: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** Event that fired when the mouse is out of the view */
    onOut: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /**
     * Event that fired when mouse up event happens outside of the button
     * after the down event happened inside the button boundaries.
     */
    onUpOut: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    private _isDown;
    private _isMouseIn;
    private _enabled;
    /**
     * Turns a given container-based view into a button by adding all button events.
     * @param {Container} view - Contained-based view
     */
    constructor(view: Container);
    /**
     * Method called when the button pressed.
     * To be overridden.
     * @param {FederatedPointerEvent} _e - event data
     */
    down(_e?: FederatedPointerEvent): void;
    /**
     * Method called when the button is up.
     * To be overridden.
     * @param {FederatedPointerEvent} _e - event data
     */
    up(_e?: FederatedPointerEvent): void;
    /**
     * Method called when the mouse hovers the button.
     * To be overridden.
     * This is fired only on PC.
     * @param {FederatedPointerEvent} _e - event data
     */
    hover(_e?: FederatedPointerEvent): void;
    /**
     * Method called when the mouse press down the button.
     * To be overridden.
     * This is fired only on PC.
     * @param {FederatedPointerEvent} _e - event data
     */
    press(_e?: FederatedPointerEvent): void;
    /**
     * Method called when the mouse leaves the button.
     * To be overridden.
     * This is fired only on PC.
     * @param {FederatedPointerEvent} _e - event data
     */
    out(_e?: FederatedPointerEvent): void;
    /**
     * Method called when the up event happens outside of the button,
     * after the down event happened inside the button boundaries.
     * To be overridden.
     * This is fired only on PC.
     * @param {FederatedPointerEvent} _e - event data
     */
    upOut(_e?: FederatedPointerEvent): void;
    /** Getter that returns if the button is down. */
    get isDown(): boolean;
    /**
     * Swither, which prevents all button events from firing.
     * @param {boolean} enabled
     */
    set enabled(enabled: boolean);
    /** Getter that returns button state, that controls if button events are firing. */
    get enabled(): boolean;
    private _processUp;
    private _processUpOut;
    private _processOut;
    private _upOut;
    private _out;
    private createEvents;
}
//# sourceMappingURL=Button.d.ts.map